{
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "exec": [
          "// Newman automatically sets all CSV column values as variables",
          "// This runs once per CSV row (97 iterations total)",
          "",
          "// Set current date in dd-mm-yyyy format",
          "const today = new Date().toLocaleDateString('en-GB').split('/').join('-');",
          "pm.variables.set('input_request_date', today);",
          "",
          "const testId = pm.variables.get('test_id');",
          "const testDescription = pm.variables.get('test_description');",
          "const expectedHttp = pm.variables.get('expected_http_status');",
          "const expectedApp = pm.variables.get('expected_app_status');",
          "",
          "// Log current test details",
          "console.log(`\\n[TEST] Test ${testId}: ${testDescription}`);",
          "console.log(`[INPUT] Input Data:`, {",
          "    PAN: pm.variables.get('input_pan_no') || 'BLANK',",
          "    DOB: pm.variables.get('input_dob') || 'BLANK',",
          "    IOP: pm.variables.get('input_iop_flag') || 'BLANK',",
          "    POS: pm.variables.get('input_pos_code') || 'BLANK',",
          "    OKRA_Code: pm.variables.get('input_okra_code') || 'BLANK',",
          "    OKRA_Batch: pm.variables.get('input_okra_batch') || 'BLANK',",
          "    Req_Date: pm.variables.get('input_request_date') || 'BLANK',",
          "    Total_Records: pm.variables.get('input_total_records') || 'BLANK'",
          "});",
          "console.log(`[EXPECTED] Expected: HTTP ${expectedHttp}, App: ${expectedApp}`);"
        ]
      }
    },
    {
      "listen": "test",
      "script": {
        "exec": [
          "// Get expected values from CSV data (automatically set by Newman)",
          "const expectedHttpStatus = parseInt(pm.variables.get('expected_http_status'));",
          "const expectedAppStatus = pm.variables.get('expected_app_status');",
          "const testId = pm.variables.get('test_id');",
          "const testDescription = pm.variables.get('test_description');",
          "",
          "// Test 1: HTTP Status Code",
          "pm.test(`${testId} - HTTP Status should be ${expectedHttpStatus}`, function () {",
          "    pm.response.to.have.status(expectedHttpStatus);",
          "});",
          "",
          "// Test 2: Response Time",
          "pm.test(`${testId} - Response time (\u003c 5000ms)`, function () {",
          "    pm.expect(pm.response.responseTime).to.be.below(5000);",
          "});",
          "",
          "// Test 3: Content Type",
          "pm.test(`${testId} - Response content type is XML`, function () {",
          "    const contentType = pm.response.headers.get('Content-Type');",
          "    pm.expect(contentType).to.include('xml');",
          "});",
          "",
          "// Parse XML and validate response fields",
          "const responseText = pm.response.text();",
          "const xml2js = require('xml2js');",
          "const parseString = xml2js.parseString;",
          "",
          "parseString(responseText, { explicitArray: false }, (err, result) =\u003e {",
          "    if (err) {",
          "        console.error('Error parsing XML:', err);",
          "        pm.test(`${testId} - XML response parseable`, function () {",
          "            pm.expect.fail('Failed to parse XML response: ' + err.message);",
          "        });",
          "        return;",
          "    }",
          "    ",
          "    try {",
          "        // Extract response structure",
          "        const envelope = result['soap12:Envelope'] || result['soap:Envelope'];",
          "        const body = envelope['soap12:Body'] || envelope['soap:Body'];",
          "        const panValidationResponse = body['PANValidationResponse'];",
          "        const panValidationResult = panValidationResponse['PANValidationResult'];",
          "        const appResRoot = panValidationResult['APP_RES_ROOT'];",
          "        ",
          "        if (expectedHttpStatus === 200) {",
          "            // Validate response structure",
          "            pm.test(`${testId} - Response has correct SOAP structure`, function () {",
          "                pm.expect(appResRoot).to.be.an('object');",
          "                pm.expect(appResRoot['APP_PAN_INQ']).to.be.an('object');",
          "                pm.expect(appResRoot['APP_PAN_SUMM']).to.be.an('object');",
          "            });",
          "            ",
          "            const panInq = appResRoot['APP_PAN_INQ'];",
          "            const panSumm = appResRoot['APP_PAN_SUMM'];",
          "            ",
          "            // Test APP_STATUS field specifically",
          "            pm.test(`${testId} - APP_STATUS should be ${expectedAppStatus}`, function () {",
          "                pm.expect(panInq['APP_STATUS']).to.equal(expectedAppStatus);",
          "            });",
          "            ",
          "            // Validate PAN number is returned",
          "            const inputPan = pm.variables.get('input_pan_no');",
          "            if (inputPan) {",
          "                pm.test(`${testId} - PAN number echoed correctly`, function () {",
          "                    pm.expect(panInq['APP_PAN_NO']).to.equal(inputPan);",
          "                });",
          "            }",
          "            ",
          "            // Validate OKRA code is returned",
          "            const inputOkraCode = pm.variables.get('input_okra_code');",
          "            if (inputOkraCode) {",
          "                pm.test(`${testId} - OKRA code preserved`, function () {",
          "                    pm.expect(panSumm['APP_OTHKRA_CODE']).to.equal(inputOkraCode);",
          "                });",
          "            }",
          "            ",
          "            // Validate OKRA batch is returned",
          "            const inputOkraBatch = pm.variables.get('input_okra_batch');",
          "            if (inputOkraBatch) {",
          "                pm.test(`${testId} - OKRA batch preserved`, function () {",
          "                    pm.expect(panSumm['APP_OTHKRA_BATCH']).to.equal(String(inputOkraBatch));",
          "                });",
          "            }",
          "            ",
          "            // Validate total records is returned",
          "            const inputTotalRecords = pm.variables.get('input_total_records');",
          "            if (inputTotalRecords) {",
          "                pm.test(`${testId} - Total records preserved`, function () {",
          "                    pm.expect(panSumm['APP_TOTAL_REC']).to.equal(String(inputTotalRecords));",
          "                });",
          "            }",
          "            ",
          "            // Validate response date format",
          "            pm.test(`${testId} - Response date is present`, function () {",
          "                const responseDate = panSumm['APP_RESPONSE_DATE'];",
          "                pm.expect(responseDate).to.be.a('string');",
          "                pm.expect(responseDate.length).to.be.greaterThan(0);",
          "            });",
          "            ",
          "        } else {",
          "            // For non-200 responses, still try to parse if XML structure exists",
          "            console.log(`[${testId}] Non-200 response - checking for error structure`);",
          "        }",
          "        ",
          "    } catch (parseError) {",
          "        console.error('Error extracting fields from parsed XML:', parseError);",
          "        pm.test(`${testId} - XML structure should be valid`, function () {",
          "            pm.expect.fail('Failed to extract fields from XML: ' + parseError.message);",
          "        });",
          "    }",
          "});",
          "",
          "// Test 5: SOAP Envelope Structure",
          "pm.test(`${testId} - Valid SOAP response structure`, function () {",
          "    pm.expect(responseText).to.match(/\u003csoap.*:Envelope|\u003c.*:Envelope/);",
          "    pm.expect(responseText).to.include('PANValidation');",
          "});",
          "",
          "// Log test completion",
          "if (pm.test \u0026\u0026 pm.test.results \u0026\u0026 pm.test.results.length \u003e 0) {",
          "    const testResults = pm.test.results;",
          "    const passed = testResults.filter(result =\u003e result.pass).length;",
          "    const total = testResults.length;",
          "    const status = passed === total ? '[PASS] PASS' : '[FAIL] FAIL';",
          "    ",
          "    console.log(`${status} ${testId}: ${passed}/${total} tests passed`);",
          "    ",
          "    if (passed \u003c total) {",
          "        const failures = testResults.filter(result =\u003e !result.pass);",
          "        console.log('[FAIL] Failed assertions:');",
          "        failures.forEach(failure =\u003e {",
          "            console.log(`   - ${failure.name}`);",
          "        });",
          "    }",
          "} else {",
          "    console.log(`[COMPLETE] ${testId} - Tests completed`);",
          "}"
        ]
      }
    }
  ],
  "info": {
    "description": "Data-driven collection for PAN validation API - executes with CSV data via Newman -d flag",
    "name": "PAN_Validation_Tests",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "{{test_id}} - {{test_description}}",
      "request": {
        "body": {
          "mode": "raw",
          "raw": "\u003csoap12:Envelope xmlns:soap12=\"http://www.w3.org/2003/05/soap-envelope\"\u003e\n  \u003csoap12:Body\u003e\n    \u003cPANValidation xmlns=\"https://test.cvlkra.com/\"\u003e\n      \u003cinputXML\u003e\n        \u003c![CDATA[\n          \u003cAPP_REQ_ROOT\u003e\n            \u003cAPP_PAN_INQ\u003e\n              \u003cAPP_PAN_NO\u003e{{input_pan_no}}\u003c/APP_PAN_NO\u003e\n              \u003cAPP_PAN_DOB\u003e{{input_dob}}\u003c/APP_PAN_DOB\u003e\n              \u003cAPP_IOP_FLG\u003e{{input_iop_flag}}\u003c/APP_IOP_FLG\u003e\n              \u003cAPP_POS_CODE\u003e{{input_pos_code}}\u003c/APP_POS_CODE\u003e\n            \u003c/APP_PAN_INQ\u003e\n            \u003cAPP_SUMM_REC\u003e\n              \u003cAPP_OTHKRA_CODE\u003e{{input_okra_code}}\u003c/APP_OTHKRA_CODE\u003e\n              \u003cAPP_OTHKRA_BATCH\u003e{{input_okra_batch}}\u003c/APP_OTHKRA_BATCH\u003e\n              \u003cAPP_REQ_DATE\u003e{{input_request_date}}\u003c/APP_REQ_DATE\u003e\n              \u003cAPP_TOTAL_REC\u003e{{input_total_records}}\u003c/APP_TOTAL_REC\u003e\n            \u003c/APP_SUMM_REC\u003e\n          \u003c/APP_REQ_ROOT\u003e\n        ]]\u003e\n      \u003c/inputXML\u003e\n      \u003cuserName\u003ecvl.admin\u003c/userName\u003e\n      \u003cPosCode\u003ecvlkra20\u003c/PosCode\u003e\n      \u003cpassword\u003e{{password}}\u003c/password\u003e\n      \u003cPassKey\u003e123\u003c/PassKey\u003e\n    \u003c/PANValidation\u003e\n  \u003c/soap12:Body\u003e\n\u003c/soap12:Envelope\u003e"
        },
        "header": [
          {
            "key": "SOAPAction",
            "value": "{{protocol}}://{{base_url}}/pan_validation"
          },
          {
            "key": "Content-Type",
            "value": "application/xml"
          }
        ],
        "method": "POST",
        "url": {
          "host": [
            "{{base_url}}"
          ],
          "path": [
            "pan_validation"
          ],
          "protocol": "{{protocol}}",
          "raw": "{{protocol}}://{{base_url}}/pan_validation"
        }
      }
    }
  ],
  "variable": [
    {
      "key": "base_url",
      "type": "default",
      "value": "localhost:8083"
    },
    {
      "key": "protocol",
      "type": "default",
      "value": "http"
    }
  ]
}
